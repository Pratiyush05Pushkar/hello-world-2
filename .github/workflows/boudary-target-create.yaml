name: Put targets in boundary
run-name: Adding targets in boundary

on: push

jobs:
  build:
    runs-on: self-hosted
    name: Put targets in boundary
    steps:
      - uses: dcarbone/install-yq-action@v1.0.0
      - uses: dcarbone/install-jq-action@v1.0.1
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Read files changed in recent git push
        id: changed-files-specific
        uses: tj-actions/changed-files@v34
        with:
          files: |
            Vault-secrets/boundary/prod/apps/**
            Vault-secrets/boundary/stage/apps/**
      - name: Set Workflow Environment variables
        id: env_var
        run: |
            echo "STAGE_PROJECT_ID=p_Jv4BjggzW9" >> "$GITHUB_ENV"
            echo "PROD_PROJECT_ID=p_HBZMfr6PcE" >> "$GITHUB_ENV"
            echo "AUTH_ID=ampw_sC1BbzThIj" >> "$GITHUB_ENV"
            echo "BOUNDARY_URL=http://127.0.0.1:9200" >> "$GITHUB_ENV"
            echo "VAULT_URL=http://127.0.0.1:8200" >> "$GITHUB_ENV"

            echo "{\"command\":\"login\",\"type\":null,\"attributes\":{\"login_name\":\"admin\",\"password\":\"${{ secrets.BOUNDARY_LOGIN_PASSWORD }}\"}}" > payload.json
            curl --request POST --data @payload.json $BOUNDARY_URL"/v1/auth-methods/${AUTH_ID}:authenticate" > response.json
            echo "TOKEN=$(jq -r '.attributes.token' response.json)" >> "$GITHUB_ENV"

      #      .github/workflows/boudary-target-create.yaml
      # - name: Run step if any file(s) in the Vault-secret folder change
      #   if: steps.changed-files-specific.outputs.any_changed == 'true'
      #   run: |
      #     for file in ${{ steps.changed-files-specific.outputs.all_changed_files }} ; do
      #       yq -o=json $file
      #     done
      # Prints the changes when done / added - Git Actions does not run when file is removed ******
      - name: To upload targets
        run: |
            #genericMethods

            #deleteEntityById(filename, entityName, entityDeleteEndpoint, token)
            deleteEntityById(){
              echo Trying to delete $3
              cat $1
              entity_id_to_del=$(jq -r --arg entity_name $2 '.items[]? | select(.name==$entity_name) | .id' $1)
              entity_id_to_del_trim="${entity_id_to_del%\"}"
              entity_id_to_del_trim="${entity_id_to_del_trim#\"}"
              curl --header "Authorization: Bearer ${4}" --request DELETE ${{ env.BOUNDARY_URL }}/$3$entity_id_to_del_trim > response_on_del.json
              echo $3 used to delete $entity_id_to_del
              echo Message is being displayed
              cat response_on_del.json
            }

            #getRequest(token, endpoint)
            getRequest() {
              curl --header "Authorization: Bearer $1" --request GET $2
            }

            #deleteFromVaultRequest(endpoint)
            deleteFromVaultRequest(){
              curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request DELETE $1
            }

            for val in ${{ steps.changed-files-specific.outputs.all_changed_files }}
            do
                #get project id
                project_name=$(yq ".project" $val)
                project_id=""
                if [[ $val == *"/stage/"* ]] ;
                then
                  echo STAGING $val
                  project_id=${{ env.STAGE_PROJECT_ID }}
                else
                  echo PROD $val
                  project_id=${{ env.PROD_PROJECT_ID }}
                fi

                #read host-catalog from yaml file
                host_catalog_name=$(yq ".host-catalog.name" $val)
                host_catalog_description=$(yq ".host-catalog.description" $val)

                #get host-catalog list
                curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request GET ${{ env.BOUNDARY_URL }}"/v1/host-catalogs?scope_id="$project_id > all_host_catalogs.json
                host_catalog_id=""
                #$(jq -r --arg hc_name $host_catalog_name '.items[]? | select(.name==$hc_name) | .id' all_host_catalogs.json)
                host_catalog_name_list=$(jq ".items[].name" all_host_catalogs.json)

                if [[ $( echo $host_catalog_name_list | grep $host_catalog_name ) ]]; then
                  host_catalog_id=$(jq -r --arg hc_name $host_catalog_name '.items[]? | select(.name==$hc_name) | .id' all_host_catalogs.json)
                else
                  echo Near to create Host_catalog_id $host_catalog_id
                  echo "{\"type\":\"static\",\"name\":\"${host_catalog_name}\",\"description\":\"${host_catalog_description}\",\"scope_id\":\"${project_id}\"}" > host_catalog.json
                  host_catalog_id=$(curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request POST --data @host_catalog.json ${{ env.BOUNDARY_URL }}/v1/host-catalogs | jq '.id' )
                  host_catalog_id_trim="${host_catalog_id%\"}"
                  host_catalog_id="${host_catalog_id_trim#\"}"
                  rm -f host_catalog.json
                fi

                #get host-sets , hosts , targets and credential stores which are already present
                curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request GET ${{ env.BOUNDARY_URL }}/v1/host-sets?host_catalog_id=$host_catalog_id > all_host_sets.json
                curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request GET ${{ env.BOUNDARY_URL }}/v1/hosts?host_catalog_id=$host_catalog_id > all_hosts.json
                curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request GET ${{ env.BOUNDARY_URL }}/v1/targets?scope_id=$project_id > all_targets.json
                curl --header "Authorization: Bearer ${{ env.TOKEN }}" --request GET ${{ env.BOUNDARY_URL }}/v1/credential-stores?scope_id=$project_id > all_credential_stores.json

                #host-sets already present in Boundary
                old_host_set_list=$(jq -r '. | select(.items) | .items[].name' all_host_sets.json)

                #host-sets in recent yaml file
                new_host_set_list=$(yq ".host-catalog.hosts[].name" $val)_set
                # new_host_set_list=$(yq ".host-catalog.host-sets[].name" $val)

                #diff gets us deleted host-sets and newly created host-sets
                diff_host_set=$(echo ${old_host_set_list[@]} ${new_host_set_list[@]} | tr ' ' '\n' | sort | uniq -u )
                echo Diff_host_Set is $diff_host_set
                echo Host_Catalog_Id $host_catalog_id

                echo Diff_host_Set after changing is $diff_host_set
                echo New_host_Set is $new_host_set_list
                for diff_hs in $diff_host_set
                do
                    if [[ $( echo $old_host_set_list | grep $diff_hs ) ]]; then
                        #deleted host-set in recent git-push
                        host_set_name=$diff_hs
                        host_name=$( echo "${diff_hs%_set}" )
                        read_target_name="$( echo $host_name )_read_target"
                        write_target_name="$( echo $host_name )_write_target"
                        credential_store_name="$( echo $host_name )_cred_store"
                        echo To delete $host_set_name $host_name $target_name
                        #deleteEntityById(filename, entityType, entityDeleteEndpoint)

                        #delete host
                        deleteEntityById all_hosts.json $host_name "v1/hosts/" $token

                        #delete host-set
                        deleteEntityById all_host_sets.json $host_set_name "v1/host-sets/" ${{ env.TOKEN }}

                        #delete read only target
                        deleteEntityById all_targets.json $read_target_name "v1/targets/" ${{ env.TOKEN }}

                        #delete write target
                        deleteEntityById all_targets.json $write_target_name "v1/targets/" ${{ env.TOKEN }}

                        #delete credential store
                        deleteEntityById all_credential_stores.json $credential_store_name "v1/credential-stores/" ${{ env.TOKEN }}

                        #delete read only db_role from vault
                        read_db_role_name=$( echo $host_name )_read_role
                        deleteFromVaultRequest ${{ env.VAULT_URL }}/v1/database/roles/${read_db_role_name}

                        #delete write db_role from vault
                        write_db_role_name=$( echo $host_name )_write_role
                        deleteFromVaultRequest ${{ env.VAULT_URL }}/v1/database/roles/${write_db_role_name}

                        #delete db_connection from vault
                        db_connection_name=$( echo $host_name )_db
                        deleteFromVaultRequest ${{ env.VAULT_URL }}/v1/database/config/${db_connection_name}

                        #delete boundary access policy from vault
                        db_policy_name=$( echo $host_name )_db_policy
                        deleteFromVaultRequest ${{ env.VAULT_URL }}/v1/sys/policies/acl/${db_policy_name}
                    fi
                    if [[ $( echo $new_host_set_list | grep $diff_hs ) ]]; then
                        #newly created host-set in recent git-push
                        host="${diff_hs%_set}" yq '.host-catalog.hosts[] | select(.name==env(host))' $val > data.yaml

                        #create host-set
                        host_set_name=$(yq ".name" data.yaml)_set
                        host_set_description=$(yq ".description" data.yaml)
                        echo "{\"host_catalog_id\":\"${host_catalog_id}\",\"name\":\"${host_set_name}\",\"description\":\"${host_set_description}\"}" > new_host_set.json
                        host_set_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @new_host_set.json $BOUNDARY_URL/v1/host-sets | jq '.id' )
                        echo Created host-set $host_set_name with id $host_set_id

                        #create host
                        host_name=$(yq ".name" data.yaml)
                        host_description=$(yq ".description" data.yaml)
                        host_ip=$(yq ".address" data.yaml)
                        host_username=$(yq ".username" data.yaml)
                        host_password=$(yq ".password" data.yaml)
                        echo "{\"attributes\":{\"address\":\"${host_ip}\"},\"type\":\"static\",\"host_catalog_id\":\"${host_catalog_id}\",\"name\":\"${host_name}\",\"description\":\"${host_description}\"}" > host.json
                        host_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @host.json $BOUNDARY_URL/v1/hosts | jq '.id' )
                        echo Create Host $host_name with id $host_id

                        #add host to host-set
                        echo "{\"version\":1,\"host_ids\":[${host_id}]}" > add_host_to_host_set.json
                        host_set_id_trim="${host_set_id%\"}"
                        host_set_id_trim="${host_set_id_trim#\"}"
                        curl --header "Authorization: Bearer ${token}" --request POST --data @add_host_to_host_set.json $BOUNDARY_URL/v1/host-sets/$host_set_id_trim:add-hosts
                        echo Added host $host_id in host-set $host_set_id_trim

                        #create READ and WRITE targets
                        read_target_name=$(yq ".name" data.yaml)_read_target
                        write_target_name=$(yq ".name" data.yaml)_write_target
                        target_description="$(yq ".host-catalog.name" $val) db"
                        #$(yq ".description" data.yaml)
                        target_default_port=$(yq ".default_port" data.yaml)
                        echo "{\"attributes\":{\"default_port\":${target_default_port}},\"type\":\"tcp\",\"name\":\"${read_target_name}\",\"description\":\"${target_description}\",\"session_max_seconds\":28800,\"session_connection_limit\":-1,\"worker_filter\":null,\"scope_id\":\"${project_id}\"}" > read_target.json
                        echo "{\"attributes\":{\"default_port\":${target_default_port}},\"type\":\"tcp\",\"name\":\"${write_target_name}\",\"description\":\"${target_description}\",\"session_max_seconds\":28800,\"session_connection_limit\":-1,\"worker_filter\":null,\"scope_id\":\"${project_id}\"}" > write_target.json
                        cat read_target.json
                        cat write_target.json
                        read_target_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @read_target.json $BOUNDARY_URL/v1/targets | jq '.id' )
                        write_target_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @write_target.json $BOUNDARY_URL/v1/targets | jq '.id' )
                        echo Created Targets with id $read_target_id and $write_target_id

                        #add host-set in target
                        echo "{\"version\":1,\"host_source_ids\":[${host_set_id}]}" > add_host_set_to_target.json
                        read_target_id_trim="${read_target_id%\"}"
                        write_target_id_trim="${write_target_id%\"}"
                        read_target_id_trim="${read_target_id_trim#\"}"
                        write_target_id_trim="${write_target_id_trim#\"}"
                        curl --header "Authorization: Bearer ${token}" --request POST --data @add_host_set_to_target.json $BOUNDARY_URL/v1/targets/$read_target_id_trim:add-host-sources
                        curl --header "Authorization: Bearer ${token}" --request POST --data @add_host_set_to_target.json $BOUNDARY_URL/v1/targets/$write_target_id_trim:add-host-sources
                        rm -f add_host_set_to_target.json
                        echo Added host-set $host_set_id in target $read_target_id_trim and $write_target_id

                        db_connection_name="$( echo $host_name )_db"
                        db_credential_create_read_role="$( echo $host_name )_read_role"
                        db_credential_create_write_role="$( echo $host_name )_write_role"
                        host_engine=$(yq ".db_engine" data.yaml)
                        if [ $host_engine == "mysql" ] ;then

                          echo "{\"backend\":\"database\",\"name\":\"${db_connection_name}\",\"plugin_name\":\"mysql-database-plugin\",\"verify_connection\":true,\"connection_url\":\"{{username}}:{{password}}@tcp(${host_ip}:${target_default_port})\/\",\"username\":\"${host_username}\",\"password\":\"${host_password}\",\"max_open_connections\":4,\"max_idle_connections\":0,\"max_connection_lifetime\":\"0s\"}" > db_connection_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_connection_payload.json $VAULT_URL/v1/database/config/$db_connection_name

                          #creat read only vault role for database-user creation
                          echo "{\"backend\":\"database\",\"name\":\"${db_credential_create_read_role}\",\"type\":\"dynamic\",\"default_ttl\":\"1h\",\"max_ttl\":\"24h\",\"rotation_period\":\"24h\",\"creation_statements\":[\"CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON *.* TO '{{name}}'@'%';\"],\"path\":\"roles\",\"db_name\":\"${db_connection_name}\"}" > db_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_role_payload.json $VAULT_URL/v1/database/roles/$db_credential_create_read_role

                          #creat write only vault role for database-user creation
                          echo "{\"backend\":\"database\",\"name\":\"${db_credential_create_write_role}\",\"type\":\"dynamic\",\"default_ttl\":\"1h\",\"max_ttl\":\"24h\",\"rotation_period\":\"24h\",\"creation_statements\":[\"CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, PROCESS, REFERENCES, INDEX, ALTER, SHOW DATABASES, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE ROLE, DROP ROLE ON *.* TO '{{name}}'@'%' WITH GRANT OPTION ;FLUSH PRIVILEGES;\"],\"path\":\"roles\",\"db_name\":\"${db_connection_name}\"}" > db_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_role_payload.json $VAULT_URL/v1/database/roles/$db_credential_create_write_role

                          #add READ and WRITE roles in same DB connection
                          echo "{\"allowed_roles\":[\"${db_credential_create_read_role}\"]}" > allowed_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @allowed_role_payload.json $VAULT_URL/v1/database/config/$db_connection_name
                          echo "{\"allowed_roles\":[\"${db_credential_create_write_role}\"]}" > allowed_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @allowed_role_payload.json $VAULT_URL/v1/database/config/$db_connection_name


                        elif [ $host_engine == "postgresql" ] ;then

                          echo Postgres db connection
                          database_name=$(yq ".database_name" data.yaml)
                          echo "{\"backend\":\"database\",\"name\":\"${db_connection_name}\",\"plugin_name\":\"postgresql-database-plugin\",\"verify_connection\":true,\"connection_url\":\"postgresql://{{username}}:{{password}}@${host_ip}:${target_default_port}/${database_name}\",\"username\":\"${host_username}\",\"password\":\"${host_password}\",\"max_open_connections\":4,\"max_idle_connections\":0,\"max_connection_lifetime\":\"0s\"}" > db_connection_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_connection_payload.json $VAULT_URL/v1/database/config/$db_connection_name

                          #creat read vault role for database-user creation
                          echo "{\"backend\":\"database\",\"name\":\"${db_credential_create_read_role}\",\"type\":\"dynamic\",\"default_ttl\":\"1h\",\"max_ttl\":\"24h\",\"rotation_period\":\"24h\",\"creation_statements\":[\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\"],\"path\":\"roles\",\"db_name\":\"${db_connection_name}\"}" > db_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_role_payload.json $VAULT_URL/v1/database/roles/$db_credential_create_read_role

                          #creat write vault role for database-user creation
                          echo "{\"backend\":\"database\",\"name\":\"${db_credential_create_write_role}\",\"type\":\"dynamic\",\"default_ttl\":\"1h\",\"max_ttl\":\"24h\",\"rotation_period\":\"24h\",\"creation_statements\":[\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\"],\"path\":\"roles\",\"db_name\":\"${db_connection_name}\"}" > db_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @db_role_payload.json $VAULT_URL/v1/database/roles/$db_credential_create_write_role

                          #add READ and WRITE role in same DB connection
                          echo "{\"allowed_roles\":[\"${db_credential_create_read_role}\"]}" > allowed_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @allowed_role_payload.json $VAULT_URL/v1/database/config/$db_connection_name
                          echo "{\"allowed_roles\":[\"${db_credential_create_write_role}\"]}" > allowed_role_payload.json
                          curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @allowed_role_payload.json $VAULT_URL/v1/database/config/$db_connection_name

                        fi
                        #policy for boundary to access db_connection_role
                        db_policy="$( echo $host_name )_db_policy"
                        #read_db_policy="$( echo $host_name )_read_db_policy"
                        #write_db_policy="$( echo $host_name )_write_db_policy"

                        #Create READ + WRITE policy for boundary to access role
                        echo "{\"name\":\"${read_db_policy}\",\"policy\":\"path \\\"database/creds/${db_credential_create_read_role}\\\" {\n  capabilities = [\\\"read\\\"]\n}\n\npath \\\"database/creds/${db_credential_create_write_role}\\\" {\n  capabilities = [\\\"read\\\"]\n}\n\npath \\\"auth/token/lookup-self\\\" {\n  capabilities = [\\\"read\\\"]\n}\n\npath \\\"auth/token/renew-self\\\" {\n  capabilities = [\\\"update\\\"]\n}\n\npath \\\"auth/token/revoke-self\\\" {\n  capabilities = [\\\"update\\\"]\n}\n\npath \\\"sys/leases/renew\\\" {\n  capabilities = [\\\"update\\\"]\n}\n\npath \\\"sys/leases/revoke\\\" {\n  capabilities = [\\\"update\\\"]\n}\n\npath \\\"sys/capabilities-self\\\" {\n  capabilities = [\\\"update\\\"]\n}\"}" > vault_boundary_policy.json
                        curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @vault_boundary_policy.json $VAULT_URL/v1/sys/policy/$read_db_policy

                        #Generate vault token
                        echo "{ \"policies\": [\"${db_policy}\"],\"no_default_policy\": true,\"no_parent\": true,\"period\": \"5h\",\"renewable\": true }" > vault_db_token_payload.json
                        boundary_token=$(curl --header "X-Vault-Token:${{ secrets.VAULT_TOKEN }}" --request POST --data @vault_db_token_payload.json $VAULT_URL/v1/auth/token/create | jq '.auth.client_token' )
                        echo Token to put in boundary $boundary_token

                        #Create credential store in boundary
                        credential_store_name="$( echo $host_name )_cred_store"
                        echo "{\"type\":\"vault\",\"name\":\"${credential_store_name}\",\"description\":\"${host_description}\",\"attributes\":{\"address\":\"http://vault.default.svc.cluster.local:8200/\",\"namespace\":null,\"ca_cert\":null,\"tls_server_name\":null,\"tls_skip_verify\":false,\"token\":${boundary_token},\"client_certificate\":null,\"client_certificate_key\":null},\"scope_id\":\"${project_id}\"}" > credential_store_payload.json
                        curl --header "Authorization: Bearer ${token}" --request POST --data @credential_store_payload.json $BOUNDARY_URL/v1/credential-stores > cred_response.json
                        credential_store_id=$(jq '.id' cred_response.json)
                        echo Credential_store with name $credential_store_name created with id $credential_store_id
                        cat cred_response.json

                        #create READ credential library
                        credential_library_name="$( echo $host_name )_read_cred_lib"
                        echo "{\"type\":\"vault\",\"credential_store_id\":${credential_store_id},\"name\":\"${credential_library_name}\",\"description\":\"${host_description}\",\"attributes\":{\"http_method\":\"GET\",\"path\":\"database/creds/${db_credential_create_read_role}\"}}" > cred_lib_info.json
                        read_cred_lib_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @cred_lib_info.json $BOUNDARY_URL/v1/credential-libraries | jq '.id' )
                        echo Credential_lib created $cred_lib_id

                        #create WRITE credential library
                        credential_library_name="$( echo $host_name )_write_cred_lib"
                        echo "{\"type\":\"vault\",\"credential_store_id\":${credential_store_id},\"name\":\"${credential_library_name}\",\"description\":\"${host_description}\",\"attributes\":{\"http_method\":\"GET\",\"path\":\"database/creds/${db_credential_create_write_role}\"}}" > cred_lib_info.json
                        write_cred_lib_id=$(curl --header "Authorization: Bearer ${token}" --request POST --data @cred_lib_info.json $BOUNDARY_URL/v1/credential-libraries | jq '.id' )
                        echo Credential_lib created $cred_lib_id

                        #add READ credential library to READ target
                        echo "{\"version\":2,\"application_credential_source_ids\":[${read_cred_lib_id}]}" > add_cred_lib_to_target.json
                        echo payload for target add
                        cat add_cred_lib_to_target.json
                        curl --header "Authorization: Bearer ${token}" --request POST --data @add_cred_lib_to_target.json $BOUNDARY_URL/v1/targets/$read_target_id_trim:add-credential-sources

                        #add WRITE credential library to WRITE target
                        echo "{\"version\":2,\"application_credential_source_ids\":[${write_cred_lib_id}]}" > add_cred_lib_to_target.json
                        echo payload for target add
                        cat add_cred_lib_to_target.json
                        curl --header "Authorization: Bearer ${token}" --request POST --data @add_cred_lib_to_target.json $BOUNDARY_URL/v1/targets/$write_target_id_trim:add-credential-sources
                    fi

                done


            done



